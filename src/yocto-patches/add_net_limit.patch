diff --git a/bitbake/lib/bb/runqueue.py b/bitbake/lib/bb/runqueue.py
index ffb2d28494..9088a8c565 100644
--- a/bitbake/lib/bb/runqueue.py
+++ b/bitbake/lib/bb/runqueue.py
@@ -164,6 +164,8 @@ class RunQueueScheduler(object):
         self.rev_prio_map = None
         self.is_pressure_usable()
 
+        self.max_net_pressure = None
+
     def is_pressure_usable(self):
         """
         If monitoring pressure, return True if pressure files can be open and read. For example
@@ -234,6 +236,25 @@ class RunQueueScheduler(object):
             return limit
         return False
 
+    def exceeds_max_net(self):
+        if self.max_net_pressure is None:
+            return False
+        try:
+            with open('net_pressure.log', 'r') as f:
+                receive_diff, transmit_diff = [int(elem) for elem in f.readline().split()]
+                if receive_diff > self.max_net_pressure[0] or transmit_diff > self.max_net_pressure[1]:
+                    return True
+        # only in the beginning there's no net_pressure.log, at the start pressure is low
+        except FileNotFoundError:
+            return False
+        return False
+
+    def set_max_net_pressure(self):
+        if os.path.isfile('current_max_net_pressure.log'):
+            with open('current_max_net_pressure.log', 'r') as f:
+                max_receive_diff, max_transmit_diff = [int(elem) for elem in f.readline().split()]
+                self.max_net_pressure = (max_receive_diff, max_transmit_diff)
+
     def next_buildable_task(self):
         """
         Return the id of the first task we find that is buildable
@@ -290,9 +311,16 @@ class RunQueueScheduler(object):
                 stamp = self.stamps[tid]
                 if stamp in self.rq.build_stamps.values():
                     continue
+                if self.exceeds_max_net():
+                    if taskname == "do_fetch":
+                        continue
+                    if taskname == "do_compile":
+                        return tid
                 bestprio = prio
                 best = tid
 
+        if not self.max_net_pressure:
+            self.set_max_net_pressure()
         return best
 
     def next(self):
