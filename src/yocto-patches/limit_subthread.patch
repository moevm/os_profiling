diff --git a/bitbake/lib/bb/runqueue.py b/bitbake/lib/bb/runqueue.py
index bc7e18175d..be104a63c6 100644
--- a/bitbake/lib/bb/runqueue.py
+++ b/bitbake/lib/bb/runqueue.py
@@ -21,10 +21,11 @@ from bb import msg, event
 from bb import monitordisk
 import subprocess
 import pickle
-from multiprocessing import Process
+from multiprocessing import Process, cpu_count
 import shlex
 import pprint
 import time
+import psutil
 
 bblogger = logging.getLogger("BitBake")
 logger = logging.getLogger("BitBake.RunQueue")
@@ -185,11 +186,53 @@ class RunQueueScheduler(object):
         else:
             self.check_pressure = False
 
+    def get_child_count(self, start_value: str = None):
+
+        def is_active_process(p):
+            try:
+                return p.status() == psutil.STATUS_RUNNING
+            except psutil.NoSuchProcess:
+                return False
+
+        cur_p = psutil.Process(os.getpid())
+        with cur_p.oneshot():
+            active_childs = list(filter(lambda x: is_active_process(x), cur_p.children(recursive=True)))
+        return len(active_childs)
+        # === old hand made implemetation ===
+        if start_value is None:
+            start_value = os.getpid()
+        t = os.listdir(f"/proc/{start_value}/task/")
+        passed = set()
+        count = 0
+        while len(t) > 0:
+            x = t.pop()
+            if x in passed:
+                continue
+            passed.add(x)
+            try:
+                tt = os.listdir(f"/proc/{x}/task/")
+                t.extend(tt)
+                p = f"/proc/{x}/task/{x}/children"
+                if os.path.exists(p):
+                    with open(p, "r") as f:
+                        childs = f.read().split()
+                else:
+                    childs = []
+                if len(childs) == 0:
+                    count += 1
+                else:
+                    t.extend(childs)
+            except:
+                pass
+        return count
+
     def exceeds_max_pressure(self):
         """
         Monitor the difference in total pressure at least once per second, if
         BB_PRESSURE_MAX_{CPU|IO|MEMORY} are set, return True if above threshold.
         """
+        #if self.get_child_count() >= cpu_count():
+        #        return True
         if self.check_pressure:
             with open("/proc/pressure/cpu") as cpu_pressure_fds, \
                 open("/proc/pressure/io") as io_pressure_fds, \
@@ -250,6 +293,10 @@ class RunQueueScheduler(object):
         if self.rq.stats.active and self.exceeds_max_pressure():
             return None
 
+        if self.rq.stats.active and self.get_child_count() >= os.cpu_count() * 0.8:
+            bb.note("Max thread is exceeded, skipping new task")
+            return None
+
         # Filter out tasks that have a max number of threads that have been exceeded
         skip_buildable = {}
         for running in self.rq.runq_running.difference(self.rq.runq_complete):
@@ -277,10 +324,17 @@ class RunQueueScheduler(object):
             for tid in self.rqdata.runtaskentries:
                 self.rev_prio_map[tid] = self.prio_map.index(tid)
 
+        #skip_compile = self.rq.stats.active and self.get_child_count() >= cpu_count()
+        skip_compile = False
+
         best = None
         bestprio = None
         for tid in buildable:
             prio = self.rev_prio_map[tid]
+            full_task_name = tid.split('/')[-1]
+            full_task_name, ttype = full_task_name.rsplit(":", 2)
+            if skip_compile and ttype.find("do_compile") != -1:
+                continue
             if bestprio is None or bestprio > prio:
                 taskname = taskname_from_tid(tid)
                 if taskname in skip_buildable and skip_buildable[taskname] >= int(self.skip_maxthread[taskname]):
