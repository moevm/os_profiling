Языки:
1. [Golang](#golang)
2. [Node.js](#nodejs)

# Golang
Команда `go` кэширует выходные данные сборки (build output) для повторного использования в будущих сборках. Расположение по умолчанию для данных кэша - это подкаталог `go-build` в стандартном каталоге кэша пользователя для текущей операционной системы (можно изменять с помощью переменных среды). Кэш сборки содержит скомпилированные пакеты и другие артефакты сборки.
Также команда периодически удаляет кэшированные данные, которые недавно не использовались.
### Формирование
Если изучить, от чего зависит результат компиляции отдельного пакета в Golang, то мы увидим, как минимум:
- тэги сборки;
- значение `GCO_ENABLED`;
- значение `GOOS` и `GOARCH`;
- то, какой пакет мы в данный момент собираем.

В целом на результат (значения `cache key` и `check sum`) влияют любые входные данные, начиная от пути по которому находится пакет, заканчивая содержимым.
### Алгоритм компиляции с кэшированием
Для удобства контроля зависимостями используются файлы `go.mod` и `go.sum`.
В 1-ом хранятся версии используемых пакетов и пути к ним. Во 2-ом хэш-суммы пакетов и их `.mod` файлов. На основе этих файлов выполняются следующие шаги компиляции: 
1. Построение графа зависимостей пакетов
2. Расчёт значений `cache key` и `check sum`

	Данный процесс начинается от пакетов у которых либо нет зависимостей, либо они базовые. То есть при попытке собрать пакет `PKG2`, который зависит от `PKG1`, а `PKG1` в свою очередь не имеет каких-то зависимостей, то расчёт начинается с пакета `PKG1`. 
	Значения `check sum` для конечного пакета сильно зависит от этих же значений используемых пакетов.
3. Поиск в `go-build` по рассчитанному значению

	В случае если по значению `check sum` не найден результат, то данные пакет скомпилируется и данные будут закэшированы.
	Стоит отметить для 1 скомпилированного пакета существуют сразу 2 места хранения кэша. Допустим у нас есть посчитанное значение `check sum` для данных из [предыдущего заголовка](#Формирование). Тогда в директории `go-build` находятся:
	- `/<2 первых символа из check sum>/<check sum>-a`
	
		action file со значениями соответствия двух значений, уже рассчитанной `check sum` (для входных данных) и `check sum2` (для выходного или объектного файла пакета)
	- `/<2 первых символа из check sum2>/<check sum2>-d`
	
		Файл который скомпилировался. В данном файле также учитываются значения `check sum` пакетов от которых зависит текущий, но используются они в формате `base64`.
4. Использование полученных данных
5. Повторение пунктов 2-4 пока все пакеты не будут скомпилированы или найдены в кэше.

Инструкция по добавлению рецептов с пакетами на данном языке отличается от других только тем, что указывается путь `GOBIN_FINAL`, по которому находятся все объектные файлы, далее происходит поиск по  `cache key` или `check sum`. В случае, если объектный файл не найден запускается сборка пакета. 
# Node.js
Аналогично языку [Golang](#golang) в Node.js используются файлы для контроля зависимостей, такие как `package.json` и `package-lock.json`. В 1-ом хранятся названия зависимостей и метаданные проекта. Второй файл регулируется автоматически при исполнении команд с `npm`, он содержит в себе подзависимости, контроль версий и пути для установки.
Язык интерпретируемый, поэтому кэш (данные зависимостей) хранятся в директории `node_modules` и идентифицируется с помощью `check sum` файла `package.json`.

Аналогично языку [Golang](#golang) в Node.js используется переменная `NPM_SHRINKWRAP`, для указания пути до `npm-shrinkwrap.json` пакета. Дальнейшие действия аналогичны.

## Источники
1. https://git.openembedded.org/openembedded-core/tree/meta/classes/go.bbclass?h=pyro
2. https://blog.gopheracademy.com/advent-2015/go-in-a-yocto-project/
