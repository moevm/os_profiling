## Yocto/Bitbake caching overview
### Общие сведения
- В Yocto (bitbake) кэшируются исходные файлы, промежуточные результаты сборки (и результаты предыдущих сборок), зависимости, а также скачанный до момента текущей сборки готовые утилиты (которые используются в сборке, но сами эти утилиты не собираются из исходников, а скачиваются в виде готовых инструментов).
- Имеется возможность организации кэш-серверов (то есть определнное место, в котором заранее собраны и кэшированы какие-то блоки), в этом случае необходимо определнным образом насторить сборку - как это делается описано в [источнике 1](https://docs.yoctoproject.org/overview-manual/concepts.html#shared-state-cache) - частным случаем может быть локальная сборка в директории А, к кэшу которой предоставляется доступ из директории Б, в которой планируется запуск сборки.
- По умолчанию кэш подгружается из папки sstate-cache (если пересобираем образ).
- При пересборке образа происходит сравнение hash сумм для кэшированных данных - так выносится решение об использованнии кэша предыдущих сборок. 
- Кэш формируется по мере выполнения сборки - выполнили задачу - кэшировали
- С помощью флагов можно настроить - какие данные хотим кэшировать. 

- Инкрементная сборка = пересборка или сборка с использованием стороннего кэша


### Нахождение и анализ рецептов (заданий)
В фазе настройки BitBake устанавливает переменную BBFILES и использует её для создания списка заданий вместе с
файлами дополнения (.bbappend) для выполнения.  
BitBake анализирует каждое задание и дополнение из переменной BBFILES и записывает значения переменных в
хранилище. Файлы дополнения применяются в порядке их следования в BBFILES.
Для каждого файла создаётся свежая копия базовой конфигурации, после чего задание анализируется построчно. Для
каждого оператора inherit BitBake находит и анализирует файл класса (.bbclass), используя для поиска BBPATH. В
заключение BitBake анализирует по порядку все файлы дополнения, найденные в BBFILES. Применяется базовое
соглашение - использовать имя задания для определения частей метаданных.   
К моменту завершения разбора задания BitBake получает список определённых задач и набор данных, состоящих из
ключей и значений, а также сведения о зависимостях между задачами. Не вся эта информация требуется BitBake и
реально применяется лишь небольшая её часть для принятия решений о задании. Поэтому BitBake кэширует нужные
значения, забывая остальное. Опыт показывает, что быстрее снова проанализировать метаданные, чем записывать и
потом загружать их.
По возможности, последующие команды BitBake применяют кэшированные данные задания. Пригодность кэша
определяется сначала расчётом контрольной суммы данных базовой конфигурации (BB_HASHCONFIG_WHITELIST) и
проверкой совпадения. Совпадение контрольных сумм в расчёте и кэше говорит о неизменности задания и файлов
классов, позволяя Bitbake снова использовать их без повторного анализа.

### Работа с hash суммами (подписями)
Контрольная сумма является уникальной подписью ввода в задачу и может служить для решения вопроса о
перезапуске задачи. Поскольку изменение ввода ведёт к перезапуску задач, BitBake нужно детектировать изменение
ввода. Для shell-задач это достаточно просто, поскольку BitBake создает сценарии run для каждой задачи и можно
рассчитать контрольную сумму, которая покажет изменение данных задачи. Однако в контрольную сумму включается
не все. Во-первых, имеется фактический путь сборки задачи - рабочий каталог и его изменение не должно влиять на
вывод целевых пакетов. Упрощённый вариант исключения рабочего каталога из контрольной суммы заключается в
установке фиксированного значения. BitBake идёт дальше и применяет переменную BB_HASHBASE_WHITELIST для
задания списка переменных, которые не следует учитывать в контрольных суммах.
Другая проблема связана с наличием в сценариях run функций, которые могут не вызываться. Решение для
инкрементальной сборки содержит код, учитывающий зависимости между shell-функциями, который служит для
урезания сценариев run до минимального набора функций, что существенно смягчает эту проблему и делает сценарии
более читаемыми.
Такой же подход применяется к задачам Python. Процесс должен выяснить переменные, к которым обращается
функция Python, и вызываемые ею функции. Решение для инкрементальной сборки содержит код, который сначала
определяет зависимости переменных и функций, а затем создает контрольную сумму для входных данных задачи. Как
и для рабочих каталогов, имеются случаи, где следует игнорировать зависимости. В таких ситуациях можно указать это процессу сборки в виде PACKAGE_ARCHS[vardepsexclude] = "MACHINE", где указано, что переменная
PACKAGE_ARCHS не зависит от значения MACHINE, даже если она ссылается на неё. Существуют и случаи, когда
нужно добавить зависимости, которые BitBake не может найти. Это можно сделать в форме PACKAGE_ARCHS[vardeps]
= "MACHINE", где переменная MACHINE явно указана как зависимость для PACKAGE_ARCHS.
Возможен случай с Python, где BitBake не может определить зависимости. При работе в режиме отладки (-DDD),
BitBake выдаёт сообщения при обнаружении невозможности выяснить зависимости.
До этого рассматривался лишь прямой ввод в задачи. Вводимая таким образом информация в коде называется
базовым хэшем (basehash). Однако остаётся косвенный ввод - элементы, которые уже собраны и имеются в каталоге
сборки. Контрольная сумма (подпись) для конкретной задачи должна учитывать хэш-значения всех задач, от которых
она зависит. Выбор зависимостей для добавления задаёт политика и в результате создаётся основная контрольная
сумма, объединяющая basehash и хэш-значения всех задач, от которых имеются зависимости.
На уровне кода есть много способов воздействия на хэш-значения. В файле конфигурации BitBake можно задать
дополнительные данные для создания basehash. Приведённое ниже выражение из OE фактически исключает
зависимости от глобальных переменных (т. е. они не включаются в контрольную сумму).
 ```
 BB_HASHBASE_WHITELIST ?= "TMPDIR FILE PATH PWD BB_TASKHASH BBPATH DL_DIR \
 SSTATE_DIR THISDIR FILESEXTRAPATHS FILE_DIRNAME HOME LOGNAME SHELL TERM \
 USER FILESPATH STAGING_DIR_HOST STAGING_DIR_TARGET COREBASE PRSERV_HOST \
 PRSERV_DUMPDIR PRSERV_DUMPFILE PRSERV_LOCKDOWN PARALLEL_MAKE \
 CCACHE_DIR EXTERNAL_TOOLCHAIN CCACHE CCACHE_DISABLE LICENSE_PATH SDKPKGSUFFIX"
```
В примере не указан рабочий каталог, являющийся частью TMPDIR.
Правила включения хэш-значений с учётом цепочек зависимостей являются более сложными и обычно реализуются
функциями Python. Код в файле meta/lib/oe/sstatesig.py содержит два примера и показывает, как можно включить свои
правила в систему. Этот файл определяет два базовых генератора подписей, используемых в OpenEmbedded-Core, -
OEBasic и OEBasicHash. По умолчанию в BitBake включён фиктивный обработчик подписей noop. Это означает, что
поведение не отличается от предыдущих версий. OE-Core использует по умолчанию обработчик OEBasicHash (файл
bitbake.conf)
 BB_SIGNATURE_HANDLER ?= "OEBasicHash"
OEBasicHash в отличие от OEBasic добавляет хэш задачи в файлы штампов. Это ведёт к тому, что любое изменение
метаданных, влияющее на хэш задачи, автоматически вызывает повторный запуск задачи. В результате не нужно
увеличивать значения PR, а изменения метаданных автоматически распространяются по сборке.
Следует отметить, что конечным результатом генерации подписей является доступность в сборке некоторых данных о
зависимостях и хэш-значениях, включая:
- **BB_BASEHASH_task-taskname** - базовые хэш-значения для каждой **задачи** в задании;
- **BB_BASEHASH_filename:taskname** - базовые хэш-значения для каждой **зависимой** задачи;
- **BBHASHDEPS_filename:taskname** - зависимости для каждой **задачи**;
- **BB_TASKHASH** - хэш текущей **работающей задачи**.
Отметим, что опция -S позволяет отлаживать подписи в BitBake, поддерживая различные режимы с использованием
отладочных функций BitBake или указанного в метаданных/подписи обработчика. Простейшим параметром является
none, обеспечивающий вывод информации о подписях в каталог STAMPS_DIR указанной цели. Указание параметра
printdiff заставляет BitBake пытаться найти максимальное соответствие (например, в кэше sstate), а затем запустить
bitbake-diffsigs для совпадений с целью определения штампа и места, где дерево штампов расходится. В новых
версиях BitBake могут появиться другие обработчики подписей, запускаемые новыми параметрами опции -S.
Информация о контрольных суммах метаданных приведена в параграфе 3
### Setscene
Процесс setscene позволяет BitBake обрабатывать ранее собранные элементы, не создавая их каждый раз с нуля. Для
этого нужны надёжные сведения о совместимости с имеющимся элементом. Описанные выше подписи представляют
идеальный вариант контроля совместимости и при совпадении подписей объект можно использовать снова. При
повторном использовании объектов возникает проблема замены результата данной задачи или набора задач
предварительно собранным элементом. Для решения проблемы в BitBake используется процесс setscene.
Когда у BitBake запрошена сборка данной цели, программа сначала проверяет доступность кэшированных данных для
собираемых или промежуточных целей. При наличии такой информации BitBake использует её вместо запуска задач.
Сначала BitBake вызывает функцию, определённую переменной BB_HASHCHECK_FUNCTION, со списком задач и
соответствующих хэш-значений для планируемой сборки. Эта функция обеспечивает быстрый возврат списка задач,
для которых могут быть получены собранные результаты. Затем для каждой возвращённой задачи BitBake выполняет
setscene-версию, включающую возможный результат. Setscene-версии задач имеют суффикс _setscene. Эти задачи
выполняются и предоставляют нужные элементы (возможно, возвращая вместо этого отказ).
Как было отмечено выше, элемент может охватывать несколько задач. Например, нет смысла получать компилятор
при наличии скомпилированной версии. Для обработки таких ситуаций BitBake вызывает функцию
BB_SETSCENE_DEPVALID для каждой успешной задачи setscene, чтобы решить вопрос о получении зависимостей
этой задачи.
После выполнения всех задач setscene BitBake вызывает функцию, указанную в BB_SETSCENE_VERIFY_FUNCTION2,
со списком задач, которые BitBake считает «охваченными». Метаданные могут гарантировать корректность списка и
информировать BitBake о необходимости перезапуска определённой задачи, независимо от результата setscene.
Метаданные setscene описаны в параграфе 3.12. Контрольные суммы задач и Setscene. 
### Описание метаданных setscene. Контрольные суммы задач и Setscene

BitBake использует контрольные суммы (подписи) с setscene для решения вопроса запуска задач. Здесь
рассматривается этот процесс на примере метаданных OE.
Контрольные суммы хранятся в каталоге STAMP. Для проверки контрольных сумм служит команда bitbake-dumpsigs,
возвращающая данные подписи в читаемом формате, которые позволяют проверить входные данные, используемые
системой сборки OE при генерации подписей. Команда позволяет, например, проверить sigdata задачи do_compile для
приложения C (например, bash). Команда также показывает, что переменная CC является частью хэшируемого ввода и
изменение этой переменной будет делать штамп недействительным и приведёт к перезапуску задачи do_compile.
Ниже перечислены переменные, связанные с контрольными суммами.
- **BB_HASHCHECK_FUNCTION** указывает имя функции, вызываемой setscene для проверки хэш-значений.
- **BB_SETSCENE_DEPVALID** задаёт функцию, вызываемую BitBake для определения необходимости
выполнения зависимости setscene.
- **BB_SETSCENE_VERIFY_FUNCTION2** задаёт функцию, вызываемую для проверки списка задач, выполнение
которых запланировано до вызова основной задачи.
- **BB_STAMP_POLICY** задаёт режим сравнения временных меток в штампах.
- **BB_STAMP_WHITELIST** указывает файлы штампов, просматриваемые при политике whitelist.
- **BB_TASKHASH** содержит хэш выполняемой задачи, возвращаемый активированным генератором подписей.
- **STAMP** указывает базовый путь для создания штампов.
- **STAMPCLEAN** задаёт базовый путь для создания штампов с возможностью использования шаблонов для
сопоставления при операциях очистки.


### Загрузка данных + зеркалирование
Извлечение исходного кода или файлов занимает в BitBake несколько этапов. Код сборщика выполняет 2 основных
функции - получение файлов (возможно кэшированных) и их распаковку в указанное место (иногда указанным
способом). Получение и распаковка файлов иногда сопровождаются внесением правок (patch). Код, отвечающий за
первую часть процесса (выборка) имеет вид
```
 src_uri = (d.getVar('SRC_URI') or "").split()
 fetcher = bb.fetch2.Fetch(src_uri, d)
 fetcher.download()
```
Код организует экземпляр класса fetch, использующий список разделенных пробелами URL из переменной SRC_URI
для вызова методов загрузки файлов. За организацией экземпляра класса fetch обычно следует код
```
 rootdir = l.getVar('WORKDIR')
 fetcher.unpack(rootdir)
```
Этот код распаковывает загруженные файлы в каталоги, указанные WORKDIR.
Для удобства именование в примерах соответствует переменным OE. Для проверки кода в работе следует
использовать файл класса OE base.bbclass. Переменные SRC_URI и WORKDIR не заданы жёстко в коде сборщика,
поскольку методы сбора могут вызываться (и вызываются) с разными именами переменных. В OE, например, код
общего состояния (sstate) использует модуль fetch для выборки файлов sstate.
При вызове метода download() BitBake пытается преобразовать URL, просматривая исходные файлы в указанном ниже
порядке.
- **Pre-mirror Sites**. BitBake при поиске исходных файлов сначала просматривает PREMIRRORS.
- **Source URI**. Если файлов не найдено, BitBake использует исходную ссылку URL (например, из SRC_URI).
- **Mirror Sites**. При неудаче BitBake обращается к зеркалам, заданным переменной MIRRORS.
Для каждого переданного ему URL сборщик вызывает субмодуль, обрабатывающий данный тип URL. Это может
вызывать некоторую путаницу при представлении URL для переменной SRC_URI. Например,
```
 http://git.yoctoproject.org/git/poky;protocol=git
 git://git.yoctoproject.org/git/poky;protocol=http
```
В первом случае URL передаётся сборщику wget, который не понимает протокол git, поэтому корректным будет второй
вариант, поскольку сборщик Git понимает, как использовать транспорт HTTP.
Ниже приведено несколько примеров использования «зеркал».
```
 PREMIRRORS ?= "\
 bzr://.*/.* http://somemirror.org/sources/ \n \
 cvs://.*/.* http://somemirror.org/sources/ \n \
 git://.*/.* http://somemirror.org/sources/ \n \
 hg://.*/.* http://somemirror.org/sources/ \n \
 osc://.*/.* http://somemirror.org/sources/ \n \
 p4://.*/.* http://somemirror.org/sources/ \n \
 svn://.*/.* http://somemirror.org/sources/ \n"
 MIRRORS =+ "\
 ftp://.*/.* http://somemirror.org/sources/ \n \
 http://.*/.* http://somemirror.org/sources/ \n \
 https://.*/.* http://somemirror.org/sources/ \n"
```
Следует отметить, что BitBake поддерживает кросс-URL и возможно «зеркало» репозитория Git на сервере HTTP в
виде архива (tarball). Именно это делает отображение git:// в прошлом примере. Поскольку доступ через сеть может
быть медленным, Bitbake поддерживает кэш загруженных из сети файлов. Все нелокальные исходные файлы (т. е.
загруженные из Internet) помещаются в специальный каталог, указанный переменной DL_DIR.
Целостность файлов очень важна для воспроизводимости сборки. Для нелокальных архивов код сборщика может
проверять контрольную сумму SHA-256 или MD5, чтобы убедиться в корректности загрузки. Эти контрольные суммы
можно задать с помощью переменной SRC_URI и подходящих флагов, как показано ниже.
```
 SRC_URI[md5sum] = "value"
 SRC_URI[sha256sum] = "value"
```
Можно также указать контрольные суммы как параметр SRC_URI.
 ``` SRC_URI = "http://example.com/foobar.tar.bz2;md5sum=4a8e0f237e961fd7785d19d07fdb994d" ```
При наличии множества URI можно задать контрольные суммы напрямую (см. выше) или путём именования URL.
 ```
 SRC_URI = "http://example.com/foobar.tar.bz2;name=foo"
 SRC_URI[foo.md5sum] = 4a8e0f237e961fd7785d19d07fdb994d
```
После загрузки и проверки контрольной суммы в DL_DIR помещается штамп .done, который BitBake использует при
последующих сборках для предотвращения ненужной загрузки и новой проверки контрольной суммы. Предполагается,
что данные в локальном хранилище не могут повреждаться. Если это не так, **могут возникать серьёзные проблемы**.
При установленной переменной BB_STRICT_CHECKSUM все загрузки с неверной контрольной суммой вызывают
ошибки. Можно использовать переменную BB_NO_NETWORK, чтобы все попытки доступа в сеть вызывали
критическую ошибку. Это может быть полезно для проверки полноты зеркал и других целей.
### Распаковка полученных данных 
Распаковка обычно происходит сразу после загрузки и для всех URL (кроме Git) BitBake применяет один метод. В URL
можно указать поведение этапа распаковки, как показано ниже.
- **unpack** управляет распаковкой компонент URL. Используемое по умолчанию значение 1 включает распаковку,
а при значении 0 файлы остаются запакованными.
- **dos** применяется для файлов .zip и .jar, задавая символы перевода строки DOS в текстовых файлах.
- **basepath** указывает процессу распаковки вырезание указанных каталогов архива при распаковке.
- **subdir** задаёт распаковку указанного URL в указанный каталог внутри корневого каталога.
Распаковка может автоматически обрабатывать файлы .Z, .z, .gz, .xz, .zip, .jar, .ipk, .rpm. .srpm, .deb и .bz2, а также
различные комбинации расширений архивов.
Как было отмечено, сборщик Git имеет свой метод распаковки, оптимизированный для работы с деревьями Git. Обычно
этот метод клонирует дерево в каталог. Процесс завершается использованием ссылок, поэтому нужна лишь одна копия
метаданных Git. 

### Пример
Пример с картинкой и описание находится по [ссылке](https://docs.yoctoproject.org/overview-manual/concepts.html#bitbake-tasks-map )


### Источники
Источник 1 [En]: https://docs.yoctoproject.org/overview-manual/concepts.html#bitbake-tasks-map    
Источник 2 [En]: https://docs.yoctoproject.org/overview-manual/concepts.html#shared-state-cache  
Источник 3 [En]: https://wiki.yoctoproject.org/wiki/TipsAndTricks/Understanding_what_changed_(diffsigs_etc)      
Источник 4 [En]: https://docs.yoctoproject.org/bitbake/     
Источник 5 [Ru]: https://www.protokols.ru/WP/wp-content/uploads/2019/12/BitBake-User-Manual.pdf     
