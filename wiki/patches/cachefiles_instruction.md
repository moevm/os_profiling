## Инструкция по применению патча cachefiles.patch

1. Переместить патч cachefiles.patch в директорию poky/meta/classes-global/.
2. Применить патч: patch -p1 sstate.bbclass < cachefiles.patch
3. Запустить сборку

Проверить работу патча можно, выполнив следующие шаги:
0. Применяем патч по инструкции выше
1. Поднимаем несколько (больше одного) зеркал с кэшем и валидными индекс-файлами. Индекс файл должен называться `index.txt` и лежать на сервере в папке `sstate-cache`.
Пример строки из индекс-файла: `90/69/sstate:sed::4.9:r0::14:9069aed815f5861814b2911e26bf8d334d7830f849343ab10185aadeeb698cca_unpack.tar.zst.siginfo`.
2. Запускаем сборку, предварительно настроив конфигурацию в local.conf (должна быть указана переменная SSTATE_MIRROS на поднятые нами зеркала).
Пример правильной настройки переменной SSTATE_MIRRORS:
`SSTATE_MIRRORS ?= " \
file://.* http://10.138.70.7:8019/sstate-cache/PATH;downloadfilename=PATH \n \
file://.* http://10.138.70.7:8020/sstate-cache/PATH;downloadfilename=PATH \n \
file://.* http://10.138.70.7:8021/sstate-cache/PATH;downloadfilename=PATH \n"`
Обратите внимание, что при указании нескольких зеркал переменная SSTATE_MIRRORS должна быть настроена именно так, один недостающий/лишний символ может спровоцировать warning и/или error у bitbake'a.
3. Если всё правильно настроили, то к нашим зеркалам сначала пройдет запрос индекс-файла, а затем будут поступать запросы с кэшем, они будут приходить сразу на нужные зеркала, минуя лишние.

## Результаты, измерение ускорения опроса зеркал
Был проведен ряд экспериментов по измерению времени сверки хэш-значений. Каждый из алгоритмов (оптимизированный и стандартный) был запущен по 7 раз.

В результате оказалось, что:
1) среднее время выполнения сверки хэш-значений по оптимизированному алгоритму составляет около 0.052 секунды.
2) среднее время выполнения сверки хэш-значений по неоптимизированному (стандартному) алгоритму составляет около 32,882 секунды.

Таким образом, получаем ускорение в ~632 раза.

Эксперименты проводились при конфигурации с одним зеркалом, настроенным по протоколу http. 


Также были проведены аналогичные эксперименты сначала с 3, а потом с 15 зеркалами, чтобы увидеть, как время сверки сигнатур зависит от количества зеркал. 
Результаты с 3 зеркалами:
1) среднее время выполнения сверки хэш-значений по оптимизированному алгоритму с 3 зеркалами составило около 0.174 секунды
2) среднее время выполнения сверки хэш-значений по неоптимизированному (стандартному) алгоритму с 3 зеркалами составило около 67.6 секунд

Результаты с 15 зеркалами:
1) среднее время выполнения сверки хэш-значений по оптимизированному алгоритму с 15 зеркалами составило около 0.254 секунды
2) среднее время выполнения сверки хэш-значений по неоптимизированному (стандартному) алгоритму с 15 зеркалами составило около 194.7 секунд


## Результаты, измерение ускорения выкачивания кэша
Был проведен ряд экспериментов по измерению времени выкачивания кэша. Эксперименты были проведены в 3 сценариях:
1) с 2 зеркалами, притом что первое указанное зеркало было пусто, а на втором лежал весь кэш
2) с 2 зеркалами, где кэш был поделен на приблизительно равные части между зеркалами
3) с 15 зеркалами, где кэш был поделен на приблизительно равные части между зеркалами

Результаты экспериментов по 1 сценарию:
1) среднее время выкачивания кэша по оптимизированному алгоритму составило около 176.81 секунд
2) среднее время выкачивания кэша по неоптимизированному алгоритму составило около 186.77 секунд

Результаты экспериментов по 2 сценарию:
1) среднее время выкачивания кэша по оптимизированному алгоритму составило около 176.69 секунд
2) среднее время выкачивания кэша по неоптимизированному алгоритму составило около 181.46 секунд

Результаты экспериментов по 3 сценарию:
1) среднее время выкачивания кэша по оптимизированному алгоритму составило около 174.48 секунд
2) среднее время выкачивания кэша по неоптимизированному алгоритму составило около 255.42 секунд

Интерпретация результатов: можем увидеть, что по оптимизированному алгоритму время выкачивания всегда остается примерно одинаковым, так как не зависит от того, сколько зеркал мы поднимем, так как запросы будут отправляться сразу на нужное зеркало, и их количество таким образом остается фиксированным.
В случае с неоптимизированным алгоритмом второй сценарий выполнился немного быстрее, чем первый, так как во втором сценарии на первом зеркале тоже был кэш, и, соответственно, только для половины пакетов проходили запросы на оба зеркала, а для другой половины запросы сразу попадали на нужное зеркало.
В третьем сценарии можем увидеть, что общее время выполнения заметно увеличилось, так как запросы для каждого пакета начинали приходить с 1 по i-e зеркало, где i-e зеркало - это то, на котором лежит искомый кэш (то есть, если необходимый кэш находился на 15-м зеркале, то запросы приходили на все зеркала с 1 по 15).
