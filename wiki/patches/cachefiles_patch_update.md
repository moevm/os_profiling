## Проблема
Необходимо получать с кэш-серверов информацию о том, какие файлы с кэшем есть на сервере, а также поддерживать актуальность этой информации

### Описание логики до патча и после
Перед началом проверки зеркал и скачивания с них кэша, клиент знает о том, какие файлы с кэшем ему необходимо получить, составляется список таких файлов, в названии каждого файла содержится хэш-значение (сигнатура), то есть клиент будет искать на сервере кэш-файл с конкретной сигнатурой. Но клиент не знает, с какого зеркала он сможет получить конкретный файл, поэтому:
- до патча он опрашивал все зеркала по каждой задаче, пока не найдет такое, на котором есть искомый файл.
- после патча логика стала следующая: сначала клиент пытается получить с каждого зеркала индекс-файл, содержащий информацию о том, какие файлы есть на этом зеркале. Затем он парсит эту информацию и те задачи, которые нашлись на каком-нибудь зеркале, начинают напрямую загружаться с нужного зеркала, а затем те зеркала, с которых не удалось получить индекс-файл, опрашиваются на предмет наличия кэш-файлов оставшихся задач по стандартному алгоритму (как до патча).

Проблемы данного подхода:
- индекс-файл запрашивается целиком, а он может оказаться очень объемным
- в данный момент индекс-файл формата txt
- индекс-файл нужно поддерживать в актуальном состоянии, сейчас это не реализовано
- с клиента нужно реализовывать поддержку различных протоколов, сейчас есть поддержка http и ftp

## Варианты решения
1) Использование индекс-файла (текущий подход)
Индекс-файл - файл, лежащий на кэш-сервере, содержащий информацию обо всех файлах с кэшем. 

Логика, необходимая со стороны сервера:
- создание индекс-файла
- поддержание актуальности индекс-файла

Логика, необходимая со стороны клиента:
- парсинг индекс-файла

Поддержка актуальности индекс-файла:
- ручное поддержание актуальности (наивное решение) 
    плюсы: нет;
    минусы: необходимость следить за актуальностью индекс-файла; высокая вероятность ошибки;
- использование cron-задач, чтобы индекс-файл обновлялся самостоятельно раз в заданный интервал
    плюсы: автономное обновление; 
    минусы: вероятность получения неактуальной информации в период после обновления ФС и до выполнения cron-задачи;
- использование inotify
    плюсы: автономное обновление; реагирование на изменение ФС в реальном времени;
    минусы: ограничение на количество watch-дескрипторов, отслеживающих изменение в директориях (обычно 8192); не работает рекурсивно, то есть придется каким-то образом навешивать watch-дескрипторы на все новые появляющиеся папки в sstate-cache;

Плюсы подхода: нет необходимости менять и/или расширять логику сервера

Минусы подхода: клиенту придется перекачивать и обрабатывать большой по объему индекс-файл

2) Использование API
С использованием API отпадает проблема того, что нужно будет передавать объемный индекс-файл, так как сервер сразу будет передавать информацию, актуальную для конкретной сборки. Также отпадает необходимость думать об актуальности состояния ФС, так как сервер может обходить ФС и собирать актуальную информацию в процессе обработки запроса.

Логика, необходимая со стороны сервера:
- эндпоинт, обрабатывающий запрос от клиента

Логика, необходимая со стороны клиента:
- парсинг ответа от сервера

Существуют различные подходы к определению тех обновлений, которые следует отправить на клиента, но в сущности они сводятся к тому, что клиент инициализирует запрос на обновление пакетов, сервер в ответ отправляет метаданные о доступных версиях пакетов (метаданные могут быть как манифестами как package.json/requirements.txt, так и временными метками, хэш-кодами и т.п.), клиент, используя эту информацию, определяет, какие пакеты нужно обновить, и отправляет запросы на обновление конкретных пакетов.
В нашем случае нет нужды вводить дополнительную систему версионирования, так как клиент на момент начала опроса зеркал уже знает хэш-коды необходимых ему файлов.

Плюсы подхода: отсутствие нагрузки на сеть в виде передачи объемного индекс-файла; отсутствие необходимости заботиться о поддержании актуального состояния индекс-файла/ФС;

Минусы подхода: подход завязан на использовании сервера с конкретным API;



## Примечания
### Типы зеркал в Yocto
Из документации Yocto Project про SSTATE_MIRRORS: 'Вы можете указать каталог файловой системы или удаленный URL, такой как HTTP или FTP.'
[Документация по SSTATE_MIRRORS](https://docs.yoctoproject.org/singleindex.html#term-SSTATE_MIRRORS). 
Однако, в bitbake реализованы также многие другие fetcher'ы: [Документация по загрузчикам](https://docs.yoctoproject.org/bitbake/1.50/bitbake-user-manual/bitbake-user-manual-fetching.html),
 я не нашла примеров, где такие url прописывались бы в SSTATE_MIRRORS, но теоретически это возможно.
