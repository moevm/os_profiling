## Исходный код проверки доступности зеркал

1. в sstate.bbclass устанавливается переменная BB_HASHCHECK_FUNCTION = "sstate_checkhashes", в функции sstate_checkhashes есть множества found() и missed(), куда в последствии добавляются tid найденных и ненайденных задач соответственно. Составляется список задач tasklist, содержащий кортежи вида (tid, sstatefile). Выводится сообщение "Checking sstate mirror object availability" (которое мы можем увидеть в начале сборки), а затем для каждой задачи из tasklist вызывается метод checkstatus, определенный в этом же файле
2. В методе checkstatus для каждой задачи инициализируется объект класса Fetch, объявленного в https://github.com/yoctoproject/poky/blob/28fd497a26bdcc12d952f81436a6d873d81cd462/bitbake/lib/bb/fetch2/__init__.py. В конструкторе класса Fetch в поле self.ud для каждого url инициализируется объект класса FetchData, объявленного в этом же файле. Класс FetchData хранит состояние для заданного url. В конструкторе класса FetchData происходит итерирование по списку methods (объявленном в этом же файле), и для каждого выполняется проверка, поддерживает ли этот метод заданный url. После нахождения первого поддерживаемого метода цикл прекращается.
3. Объекты, хранящиеся в списке methods - это объекты классов-методов, являющихся наследниками (конкретными реализациями) класса FetchMethod, например класс Wget поддерживает протоколы 'http', 'https', 'ftp', 'ftps'.
4. Далее в sstate.bbclass вызывается метод checkstatus класса Fetch, который, в свою очредь, вызывает методы checkstatus и try_mirrors класса FetchMethod поочередно сначала для PREMIRRORS, потом для original uri, затем для MIRRORS. Метод try_mirrors класса FetchMethod вызывает функцию try_mirrors, которая строит uri для зеркала и вызывает функцию try_mirror_url, которая возвращает False, если необходимо попробовать другой url (то есть данный является нерабочим)



## Общая схема того, что происходит
1. В файле bitbake/lib/bb/runqueue.py в самом начале метода _execute_runqueue класса RunQueue вызывается метод класса RunQueueData prepare(). Данный метод выполняет подготовку к сборке, вот общий комментарий из исходного кода bitbake этого метода: "Turn a set of taskData into a RunQueue and compute data needed to optimise the execution order", то есть "Преобразует набор данных задач в очередь выполнения и вычисляет данные, необходимые для оптимизации порядка выполнения". По сути данный метод делает следующее: 
    1) Выполянется разрешение всех видов зависимостей, тем самым образуя очередь выполнения
    2) Заполняются данные о кэше задач, которые потом передаеются в sstate_checkhashes
            2.1. Данные о кэше заполняются следующим образом: вызывается код из bitbake/lib/bb/siggen.py, который выполняет генерацию хэша. В данном файле выполняется код в соответствии с заданным значением BB_SIGNATURE_HANDLER, то есть вызывается код соответствующего класса (там несколько реализаций BB_SIGNATURE_HANDLER).
            2.2. В дальнейшем заполненные значения используются в sstate_checkhashes, когда генерируется имя sstate-файла (используется значение unihash).
2. В самом начале в функции sstate_checkhashes создаются множества found и missed. found - найденные в кэше задачи,  missed - остальные. В конце функции множество found возвращается как множество setscene задач (то есть тех, которые не нуждаются в перезапуске).
3. Внутри функции sstate_checkhashes происходит следующее:
    1) Переменная bitbake'a MIRRORS удаляется, а в переменную PREMIRRORS записываются SSTATE_MIRRORS, таким образом, на первом шаге, описанном в п.5, произойдет именно проверка SSTATE_MIRRORS, а дальше не будет лишних проверок, т.к. переменная MIRRORS удалена.
    2) создается список всех задач tasklist
    3) создается очередь соединений connection_cache_pool (объекты класса FetchConnectionCache). Длина очереди nproc устанавливается равной значению BB_NUMBER_THREADS (или, если длина tasklist меньше, чем BB_NUMBER_THREADS, тогда она устанавливается как длина tasklist). Это и будет число потоков, на которые далее распараллеливается проверка.
    4) Для каждой задачи при помощи использования класса ThreadPoolExecutor(max_workers=nproc) запускается проверка методом checkstatus (это уже происходит с распараллеливанием). То есть, когда заканчивается выполнение chechstatus для какой-то задачи, в очередь возвращается объект класса FetchConnectionCache. В это время ThreadPoolExecutor параллельно запускает проверки задач, число потоков=nproc. Например, при моей конфигурации это было 24. В данном случае connection_cache_pool это скорее вспомогательная информация, непосредственно распараллеливанием занимается объект класса ThreadPoolExecutor.
4. Внутри функции checkstatus происходит следующее:
    1) Для задачи создается объект класса Fetch (в его конструктор в качестве аргумента подается объект connection_cache, который берется как раз-таки из очереди connection_cahce_pool).
    2) вызывается его метод checkstatus.

5. Далее, если говорить обобщенно, происходит следующее: метод checkstatus класса Fetch ничего не возвращает, если находит соответствующий для задачи кэш. После такого хода выполнения метода checkstatus класса Fetch задача удаляется из множества missed и добавлятся в множество found. Иной вариант ход работы метода: если после всех проверок (PREMIRRORS, original uri, MIRRORS) метод так и не нашел соответствующего задаче кэша, то метод выбрасывает исключение FetchError, которое ловится в checkstatus внутри sstate_checkhashes, тем самым прерывая выполнение, из-за чего задача так и остается в множестве missed и не добавляется в множество found.
6. Разберем подробнее как происходит сама проверка:
    1) Внутри метода checkstatus класса Fetch сначала проверяются PREMIRRORS, затем, если там не найдено соответствующего кэша, вызывается проверка original uri, и затем, если и там ничего не найдено, вызывается проверка MIRRORS.
    2) Для PREMIRRORS и MIRRORS всё происходит аналогично: сначала берется соответствующая переменная  bitbake'а (PREMIRRORS или MIRRORS), эти "зеркала" передаются в метод try_mirros, где вызывается метод build_mirroruris, который возвращает два списка - список uris (адресов файла кэша для каждого проверяемого из зеркал), и список uds - (uri data's) - объектов класса FetchData, соответствующих каждому uri. Таким образом, эти два списка одной длины, и между их элементами есть соответствие. 
    Я проводила эксперимент с одним зеркалом, поднятым на localhost, и поэтому в моем случае из метода build_mirroruris возвращались всегда списки длины 1. Пример возвращаемого значения: `uris: ['http://127.0.0.1:8000/sstate-cache/37/5b/sstate%3Aattr%3Acore2-64-poky-linux%3A2.5.2%3Ar0%3Acore2-64%3A12%3A375b87b1b90a0f571357e6291be65aca51853aab8bca8eb02733ef029a95c85a_packagedata.tar.zst;downloadfilename=37/5b/sstate:attr:core2-64-poky-linux:2.5.2:r0:core2-64:12:375b87b1b90a0f571357e6291be65aca51853aab8bca8eb02733ef029a95c85a_packagedata.tar.zst'], uds: [<bb.fetch2.FetchData object at 0x7f3a644f4640>]`.  Далее финальный этап проверки: для каждого uri из списка uris вызывается метод try_mirror_url. Метод try_mirror_url в сценарии проверки выполняет лишь следующее: `found = ud.method.checkstatus(fetch, ud, ld)`. То есть вызывается метод checkstatus конкретного класса-метода (в моем случае, так как было поднято зеркло на localhost, это метод Local, но в случае по-другому устроенных зеркал, это будут методы соответствующих классов (все они являются наследниками FetchMethod)), а затем значение found возвращается из функции и далее вверх до метода try_mirrors. Если вернулось true - то проверка дальше не идет (например, после проверки PREMIRRORS вернулось true, значит далее проврека original uri и MIRRORS проводиться не будет). 
    3) Для original uri происходит примерно то же самое, за исключением того, что не берутся никакие переменные bitbake'a и не строятся uris. Просто вызывается метод checkstatus конкретного класса-метода и это значение возвращается в качестве результата. Аналогично, если здесь возвращается true, то проверка MIRRORS уже не происходит.
    4) В итоге, если после какой-либо из проверок: PREMIRRORS, original uri, MIRRORS вернулось true, то метод checkstatus класса Fetch завершает своё выполнение и ничего не возвращает. Иначе, если отовсюду вернулось false, выбрасывается исключение FetchError, и в функции sstate_checkhashes вызывается обработка исключения (пункт 4).

7. В результате мы получаем в множестве found необходимые setscene-задачи, в множестве missed - остальные.

## Графическая схема
![image](https://github.com/user-attachments/assets/729514b0-d4e4-4d47-bfd0-76095a5ef629)


## Вопросы к изучению
1) Где именно и как используется то, на каком IP и порту запускается хэш-сервер
2) Как именно генерируются хэш-значения (вопрос глобальный)
