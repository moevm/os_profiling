# Обзор [видео](https://www.youtube.com/watch?v=fAeZvIm7Ufc&ab_channel=TheLinuxFoundation)
## Поднимаемые темы
Способы ускорить сборку:
- использование локального кэша и конфигурация локации загрузженного исходного кода
- использование архивов исходного кода, которые распротраняются в локальных сетях
- технология, упрощающая администрирование версий пакетов - PRServ
- кэш состояний сборки и валидация кэш пакетов с помощью HashServ

## Использование локальных SSTATE_DIR И DL_DIR 
Локально можно прописывать для всех сборок одну папку расположения, SSTATE_DIR  И DL_DIR. Например представим, что если некоторый исходник был скачан во время сборки А и он требуется для сборки Б, то указание одной и той же папки в local.conf в переменной DL_DIR приведет к тому, что упомянутые исходник не будет скачан повторно во время сборки Б.

## Использование архивов исходного кода по сети  

DL_DIR из предыдущего пункта применяется только на локальной машине. Если же есть некоторая команда людей, которая занимается сборками, бывает полезным сделать архив из исходного кода. Он может быть размещен как в локальной сети, так и в глобальной. Для двух этих случаев существуют отдельные переменные сборки:
- PREMIRRORS -- эти зеркала принято использовать в качестве локальных. Они имеют больший приоритет, чем MIRRORS.
- MIRRORS -- эти зеркала принято использовать в качестве глобальных. Они имеют меньший приоритет, чем PREMIRRORS.  
  е стоит 
В конфигурации лучше указывать и PREMIRRORS и MIRRORS, поскольку в первую очередь будут просматриваться локальные PREMIRRORS, а если там ничего не найдется, то будут расматриваться MIRRORS.

## PRServ
PRServ - Package Revision Service - Сервис ревизии пакетов. Когда одну сборку разрабатывает один человек, он на каждое изменение исходного кода или состава пакета должен назначать ревизию, примерно так -- r0 -> изменение -> r1 -> изменение -> r2 -> ...  
Однако, когда над проектов работает несколько людей, то один пакет у каждого человека локально может иметь одинаковый номер ревизии, при этом содержание пакета может отличаться, примерим программист А добавил в пакет Х изменение К, а программист Б добавил в пакет Х изменение L, каждый зафиксировал локально ревизию как r1, однако могут возникнуть конфликты и путаница.  

Использование PRServ ведет к тому, что ревизия пакета растет линейно:
```
Developer 1 r0 ⇒ ⇒ r3 ⇒ ⇒ ⇒ ⇒ r8
Developer 2    r1 ⇒ ⇒ r4 ⇒ r6
Developer 3       r2 ⇒ ⇒ r5 ⇒ r7
---------------------------------> time
```
## HashServ
SSTATE-CACHE формируется в процессе сборки. Использование SSTATE-CACHE и HashServ являются самым мощным инструментами ускорения процесса сборки.  
SSTATE-CACHE может быть использован повторно только в том случае, когда HashServ установил валидность конкретного пакета с помощью алгоритмов хэширования. Отсюда возникает ряд советов работы с проектом, которые повышают процент пакетов, которые могут быть восстановлены из SSTATE-CACHE:
- версии зависимых пакетов для сборки, в которой был сгененрирован SSTATE-CACHE, должны максимально совпадать с версиями пакетов целевой сборки
- не стоит использовать полные пути, особенности хоста или использовать время -- это может привести к тому, что кэш будет считаться невалидным
- системы, в которой был сгененрирован SSTATE-CACHE и та, на которой происходит целевая сборка должны быть похожими -- чем больше они одинаковые, тем больший процент кэша будет валидироваться. Чтобы обходить эти особенности, монжно либо использовать одну систему во всех проектах, например определенные релиз Ubuntu или контейнеры.

HashServ лучше размещать в локальной сети, при это к сборке можно подключить один HashServ и множество SSTATE_MIRRORS.
