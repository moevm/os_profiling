## Скачивание sstate-кэша с зеркал

В данный момент классический алгоритм bitbake'a собирает информацию о задачах, которые он может взять из кэша, но не запоминает, какую задачу с какого зеркала он может взять, а начинает вновь опрашивать зеркала о наличии конерктной задачи.
Следовательно, мы хотим сделать такую оптимизацию, чтобы в момент опроса при нахождении задачи на зеркале bitbake запоминал, с какого зеркала он будет брать эту задачу.

Реализацию данной оптимизации глобально можно разделить на 2 этапа:
1) Реализация "запоминания" bitbake'ом информации о соответствии задачи из кэша и зеркал, с которых он будет их брать
2) Встраивание автоматического выкачивания кэша с нужного зеркала в соответствии с пунктом 1.




## Реализация

Поскольку при опросе зеркал был предусмотрен оптимизирующий патч, то и реализация данной идеи будет делиться на два варианта:
1) в классическом алгоритме
2) в оптимизированном алгоритме с индекс-файлом

В данный момент предлагаемая оптимизация работает в сценарии, когда на зеркале есть индекс-файл, в ином случае обработка будет происходить по классическому алгоритму, поэтому далее будем говорить только о втором сценарии.

Алгоритм работы:
1. В процессе опроса зеркал из индекс-файлов берется информация о том, на каком зеркале какие файлы с кэшем существуют. Получаем информацию вида `{mirror1: [cachefile1, cachefile2, ..., cachefileN], 'mirror2': [cachefile2], 'mirror3': []}`.
2. После обработки всех зеркал, на которых смогли найти индекс файл, информация преобразуется в следующий вид: `{cachefile1: mirror1, cachefile2: mirror1, ...}`. Здесь `cachefile_i` - это не все файлы, полученные из индексов, а только те, которые необходимы в данной конкретной сборке - лишняя информация отфильтровывается и не записывается. В данном виде информация записыватся в файл, лежащий на клиенте (была идея прокидывать эту информацию через мета-данные bitbake`a, но реализовать такую идею не получилось, т.к. bitbake видит записанную информацию только до выхода из функции, а дальше - нет)
3. В функции fstaging_fetch, где происходит выкачивание кэша, читается записанная информация, берется необходимое зеркало (если такое существует), и запрос происходит напрямую к нему. А если для данного файла не было необходимой информации, то в соответствии с классическим алгоритмом будет считана переменная bitbake`a SSTATE_MIRRORS, и зеркала будут проверяться поочередно. 


# Итоги
1. Был проведен тест, в котором были запущены 2 зеркала с одинаковым и полным кэшем, но на первом индекс-файл был пуст, а на втором актуален. В local.conf зеркала были указаны в соответствующем порядке. В результате запросы проходили сразу на второе зеркало, как и ожидалось (при классическом алгоритме запросы бы проходили сначала на первое зеркало).
2. Было сделано наблюдение, что в функции fstaging_fetch перед вызовом метода download() сначала вызывается метод checkstatus(). Оказалось, что при отключении вызова checkstatus() на кэш-сервер перестают приходить запросы типа HEAD, а сразу приходят только GET-запросы. Сборка при этом заканчивается успешно. То есть, если раньше на зеркало запросы приходили парами: сначала HEAD, затем GET, то теперь проходят только запросы GET. Вопрос к обсуждению: зачем нужны и действительно ли необходимы HEAD-запросы, если без них сборка так же заканчивается успешно?