## Скачивание sstate-кэша с зеркал

В данный момент классический алгоритм bitbake'a собирает информацию о задачах, которые он может взять из кэша, но не запоминает, какую задачу с какого зеркала он может взять, а начинает вновь опрашивать зеркала о наличии конерктной задачи.
Следовательно, мы хотим сделать такую оптимизацию, чтобы в момент опроса при нахождении задачи на зеркале bitbake запоминал, с какого зеркала он будет брать эту задачу.

Реализацию данной оптимизации глобально можно разделить на 2 этапа:
1) Реализация "запоминания" bitbake'ом информации о соответствии задачи из кэша и зеркал, с которых он будет их брать
2) Встраивание автоматического выкачивания кэша с нужного зеркала в соответствии с пунктом 1.


## Предлагаемый вариант реализации пункта 1

Чтобы не переписывать полностью логику bitbake'a, предлагается следующая реализация:
Создать файл, лежащий на клиенте, в который будет записываться информация о найденном кэше (например, полный url файла кэша, включающий ip зеркала, на котором он был найден).

Поскольку при опросе зеркал был предусмотрен оптимизирующий патч, то и реализация данной идеи будет делиться на два варианта:
1) в классическом алгоритме
2) в оптимизированном алгоритме с индекс-файлом

Пример реализации в классическом алгоритме: 
В оптимизированном алгоритме идея пока не реализована, но скорее всего она будет несложной в реализации


## Пункт 2
Чтобы встроить предлагаемую логику в bitbake, нужно понимать, где происходит выкачивание кэша. 
После исследования исходного кода bitbake'a был найден фрагмент кода в bitbake/lib/bb/runqueue.py (функция execute, строчки 2193 - 2304), где ищется следующая задача setscene для запуска. В словарь runtask записывается информация о задаче, включающая имя файла рецепта, имя задачи, значение unihash и другое. Пример части информации:
`runtask.fn: virtual:native:/home/user/poky_new/poky/meta/recipes-devtools/gnu-config/gnu-config_git.bb, runtask.task: virtual:native:/home/user/poky_new/poky/meta/recipes-devtools/gnu-config/gnu-config_git.bb:do_recipe_qa, runtask.unihash: 29628fefae0b3e780ce68c96db3348049db42081c566269f2b12ad262c563d96` (часть отладочного вывода).
Что происходит после этого - вопрос открытый. Исходя из моего исслоедования, эта информация преобразуется в байты и отправляется в stdin bitbake-worker'a, реализация которого основана на subprocess.Popen.

Также есть функция pstaging_fetch в файле meta/classes-global/sstate.bbclass, которая делает checkstatus и download, по структуре практически аналогичные тому, что происходило при проверке зеркал. 


## Итог
Чтобы понять, подходит ли идея реализации пункта 1, нужно точно знать, где происходит выкачивание кэша с зеркал, тогда мы сможем понять, сможем ли мы встроить данную логику.