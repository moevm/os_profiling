# Yocto system image build

This file discusses the following aspects of Yocto build:

+ How files/libraries/etc. are added to the final image  
+ Where this happens in the code  
+ When this happens  
+ Whether caching is used  
+ Differences between layers and classes

### How files/libraries/etc. are added to the final image  
Files and libraries are added to the final image using bitbake, which executes the recipes generated by Yocto. That is (as I understand it) — Yocto generates recipes (depending on what we want to get — for example, if we don’t want a graphical interface, recipes for windowing systems are not generated, etc...), and all these recipes are executed directly by bitbake, which walks through them and builds the image, installing libraries, dependencies, compiling source code, etc.

### Where this happens in the code  
All recipes are located in the Yocto tree in the `./meta` folder, where they are grouped into folders named `recipes-<something>`. They are grouped by purpose — each folder contains all recipes for a specific task category (for example, kernel recipes, graphical shell recipes, external device interaction recipes...).

Description of recipes from `/meta/recipes.txt`:
```
recipes-bsp          - Anything with links to specific hardware or hardware configuration information  
recipes-connectivity - Libraries and applications related to communication with other devices  
recipes-core         - What's needed to build a basic working Linux image including commonly used dependencies  
recipes-devtools     - Tools primarily used by the build system (but can also be used on targets)  
recipes-extended     - Applications which whilst not essential add features compared to the alternatives in  
                       core. May be needed for full tool functionality.  
recipes-gnome        - All things related to the GTK+ application framework  
recipes-graphics     - X and other graphically related system libraries  
recipes-kernel       - The kernel and generic applications/libraries with strong kernel dependencies  
recipes-multimedia   - Codecs and support utilities for audio, images and video  
recipes-rt           - Provides package and image recipes for using and testing the PREEMPT_RT kernel  
recipes-sato         - The Sato demo/reference UI/UX, its associated apps and configuration  
recipes-support      - Recipes used by other recipes but that are not directly included in images
```

All these instructions, recipes, classes, layers, etc. are executed by bitbake.  
Roughly speaking (very roughly), bitbake is an orchestration tool — it controls how recipes and other things are executed.  
(There’s a lot of documentation in the `bitbake/doc` folder — this should be studied in more detail, because it is the foundation of image builds in Yocto, but there’s a lot of material...)

### When this happens

In BitBake, the file `/bitbake/lib/bb/utils.py` contains wrappers for commonly used functions (like directory creation, e.g. `mkdirhier` wraps `mkdir -p`, but avoids errors if the directory already exists).

It would be incorrect to point to a specific step, since the entire bitbake build process is tied to library/module inclusion.  
Instead, let’s outline the main stages of the image build process with bitbake:

1. **Working directory creation:** BitBake starts by reading and analyzing metadata from various layers, including recipes, classes, config files, etc. As a result, it creates a working tree containing all necessary build information (like a skeleton).  
   This is done in **lib/bb/cooker.py**, which processes recipes and manages directories for source code, intermediate build results, etc.

2. **Metadata parsing:** BitBake analyzes metadata, determines dependencies between components, configurations, etc.  
   This happens in **lib/bb/codeparser.py** and **lib/bb/parse.py**

3. **Environment configuration:** BitBake sets up the build environment, including variables and parameters needed for the build.

4. **Source fetching:** BitBake downloads sources (archives, git repos) and unpacks them into the tree.  
   Done in **lib/bb/fetch2.py**

5. **Compilation and building:** BitBake runs build tasks for each component, including compiling, linking, dependency handling, and packaging binaries, libraries, etc.

6. **Image generation:** After successfully compiling all components, BitBake combines them into the system image — filesystem, kernel, bootloader, config files, etc.

7. **Final processing:** BitBake performs final steps like packaging, signing, documentation, etc.

- **lib/bb/runqueue.py** — responsible for task scheduling and execution.  
  It also handles the working tree: copying files, installing packages, etc.

- **lib/bb/build.py** — manages the package build process and compilation, including task launching, dependency management, and build control.

* Intermediate results are cached. For example, if I started a build and it completed 90%, then I forcefully stopped it, and resumed it 20 days later — it finished (didn’t start over), so steps are cached.  
  Caching is handled in **lib/bb/cache.py**

### Is caching used

Yes, caching is used. Caches are stored in `/build/cache`, `/build/sstate-cache`, and `/build/tmp`, and downloaded sources are in `./build/downloads` (archives, source code, etc.).  
Also, as seen above, compiled components are written to their own directories in the working build tree.

### Build concept (recipes (tasks), configs, classes, layers)

#### Recipes (tasks)  
BitBake tasks, stored in `.bb` files, are base metadata providing BitBake with:
- package descriptions (author, homepage, license, etc.)  
- task versions  
- build and runtime dependencies  
- source locations and extraction methods  
- patch requirements, location, and application  
- build/compile instructions  
- install paths for target system

In BitBake (or systems using it), `.bb` files are called "recipes".  
Sometimes they’re referred to as "packages", but that’s not quite correct — a single recipe may produce multiple packages.

#### Configurators (configuration files)

`.conf` files define variables that control the build process.  
They include:
- machine and distribution configuration  
- compiler options  
- default/user settings

Main config file: `bitbake.conf` in the `conf` source tree folder.

#### Classes

`.bbclass` files contain reusable metadata shared by many recipes.  
`base.bbclass` is automatically included in all recipes and defines standard tasks like:
- fetch  
- unpack  
- configure (empty by default)  
- compile (runs if Makefile exists)  
- install (empty by default)  
- package (empty by default)

These tasks are often overridden or extended in custom classes during development.

#### Layers

Layers allow separation of configuration types.  
It might be tempting to put everything in one place, but modular structure makes maintenance easier.

For example, configs for a specific target machine are usually placed in a BSP layer (Board Support Package).  
Such configs should be isolated from recipes and metadata supporting a GUI.  
Still, BSP layers may include GUI-specific additions using BitBake append files (`.bbappend`).

#### Append Files

`.bbappend` files extend or override existing recipes.  
BitBake expects an append file to correspond to a recipe — they must have the same base name, differing only by suffix (e.g. `formfactor_0.0.bb` and `formfactor_0.0.bbappend`).

Append files add or override content in the corresponding recipe.  
You can use `%` wildcard in filenames to match multiple versions.  
Example: `busybox_1.21.%.bbappend` will match `busybox_1.21.x.bb` of different versions.

---

Source [En]: https://docs.yoctoproject.org/bitbake/  
Source [Ru]: https://www.protokols.ru/WP/wp-content/uploads/2019/12/BitBake-User-Manual.pdf
