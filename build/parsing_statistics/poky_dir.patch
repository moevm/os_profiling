diff -ruN poky1/bitbake/lib/bb/cache.py poky/bitbake/lib/bb/cache.py
--- poky1/bitbake/lib/bb/cache.py	2024-06-22 12:00:34.166582588 +0300
+++ poky/bitbake/lib/bb/cache.py	2024-06-22 11:55:03.846629205 +0300
@@ -17,6 +17,7 @@
 #
 
 import os
+import time
 import logging
 import pickle
 from collections import defaultdict
@@ -405,6 +406,8 @@
         self.cacheclean = True
         self.data_hash = data_hash
         self.filelist_regex = re.compile(r'(?:(?<=:True)|(?<=:False))\s+')
+        self.log_file = open('recipe_parsing_time.log', 'a')
+
         if self.cachedir in [None, '']:
             bb.fatal("Please ensure CACHE is set to the cache directory for BitBake to use")
 
@@ -514,6 +517,7 @@
     def parse(self, filename, appends, layername):
         """Parse the specified filename, returning the recipe information"""
         self.logger.debug("Parsing %s", filename)
+        start_time = time.time()
         infos = []
         datastores = self.databuilder.parseRecipeVariants(filename, appends, mc=self.mc, layername=layername)
         depends = []
@@ -534,6 +538,8 @@
                 info = cache_class(filename, data)
                 info_array.append(info)
             infos.append((virtualfn, info_array))
+        end_time = time.time()
+        self.log_file.write(f'{filename}: {end_time - start_time:.2f} seconds\n')
         return infos
 
     def loadCached(self, filename, appends):
diff -ruN poky1/build/create_parsing_info.py poky/build/create_parsing_info.py
--- poky1/build/create_parsing_info.py	1970-01-01 03:00:00.000000000 +0300
+++ poky/build/create_parsing_info.py	2024-06-05 19:08:19.505510456 +0300
@@ -0,0 +1,42 @@
+import os
+
+def parse_recipe_times(file_path):
+    layer_times = {}
+
+    with open(file_path, 'r') as file:
+        for line in file:
+            recipe_path, time_str = line.split(':')
+            parse_time = float(time_str.split()[0])
+            
+            parts = recipe_path.split('/')
+            layer_index = None
+            for i, part in enumerate(parts):
+                if 'meta' in part:
+                    layer_index = i
+                    break
+            
+            layer = parts[layer_index] if layer_index and layer_index < len(parts) else 'unknown'
+
+            if layer in layer_times:
+                layer_times[layer] += parse_time
+            else:
+                layer_times[layer] = parse_time
+
+    return layer_times
+
+
+def write_layer_times(layer_times, output_file):
+    with open(output_file, 'w') as file:
+        for layer, time in layer_times.items():
+            file.write(f'{layer}: {time:.2f} seconds\n')
+
+
+input_file = 'recipe_parsing_time.log'
+output_file = 'layer_parsing_time.log'
+
+# Parse the recipe times and write the layer times
+layer_times = parse_recipe_times(input_file)
+write_layer_times(layer_times, output_file)
+
+print(f'Layer parsing times written to {output_file}')
+
