diff -ruN poky/bitbake/lib/bb/cache.py poky1/bitbake/lib/bb/cache.py
--- poky/bitbake/lib/bb/cache.py	2024-06-16 20:41:34.073533000 +0300
+++ poky1/bitbake/lib/bb/cache.py	2024-06-16 20:37:35.559821100 +0300
@@ -17,6 +17,7 @@
 #
 
 import os
+import time
 import logging
 import pickle
 from collections import defaultdict
@@ -280,7 +281,7 @@
 
     @classmethod
     def reset(cls):
-        # Needs to be called before starting new streamed data in a given process 
+        # Needs to be called before starting new streamed data in a given process
         # (e.g. writing out the cache again)
         cls.save_map = {}
         cls.save_count = 1
@@ -515,6 +516,8 @@
     def parse(self, filename, appends, layername):
         """Parse the specified filename, returning the recipe information"""
         self.logger.debug("Parsing %s", filename)
+        start_time = time.time()
+
         infos = []
         datastores = self.databuilder.parseRecipeVariants(filename, appends, mc=self.mc, layername=layername)
         depends = []
@@ -536,6 +539,10 @@
                 info_array.append(info)
             infos.append((virtualfn, info_array))
 
+        end_time = time.time()
+        with open('recipe_parsing_time.log', 'a') as log_file:
+            log_file.write(f'{filename}: {end_time - start_time:.2f} seconds\n')
+
         return infos
 
     def loadCached(self, filename, appends):
diff -ruN poky/create_parsing_info.py poky1/create_parsing_info.py
--- poky/create_parsing_info.py	1970-01-01 03:00:00.000000000 +0300
+++ poky1/create_parsing_info.py	2024-06-05 19:15:57.153672000 +0300
@@ -0,0 +1,37 @@
+def parse_recipe_times(file_path):
+    layer_times = {}
+
+    with open(file_path, 'r') as file:
+        for line in file:
+            recipe_path, time_str = line.split(':')
+            parse_time = float(time_str.split()[0])
+
+            parts = recipe_path.split('/')
+            layer_index = None
+            for i, part in enumerate(parts):
+                if 'meta' in part:
+                    layer_index = i
+                    break
+
+            layer = parts[layer_index] if layer_index and layer_index < len(parts) else 'unknown'
+
+            if layer in layer_times:
+                layer_times[layer] += parse_time
+            else:
+                layer_times[layer] = parse_time
+
+    return layer_times
+
+
+def write_layer_times(layer_times, output_file):
+    with open(output_file, 'w') as file:
+        for layer, time in layer_times.items():
+            file.write(f'{layer}: {time:.2f} seconds\n')
+
+
+if __name__ == '__main__':
+    input_file = 'recipe_parsing_time.log'
+    output_file = 'layer_parsing_time.log'
+
+    layer_times = parse_recipe_times(input_file)
+    write_layer_times(layer_times, output_file)
